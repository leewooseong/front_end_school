<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>test</title>
    <style>
        .cont {
            /* test-case 1. */
            display: flex;
            /* display: inline-block; */
            /* display: block; */
            /* flex-wrap: wrap; */
            /* width: 100%; */

            height: 300px;
            background-color: cornsilk;
        }
        .cont .div1 {
            background-color: darkcyan;
            flex: 1 1px 2;
            /* width:200px; */
            /* flex-basis: 200px; */
            /* flex-shrink: 0; */
            /* flex: 80%;    */
        }
        .cont .div2 {
            background-color: darkkhaki;
            flex-basis: 200px;
            flex-grow: 1;
            /* flex: 1 1 0 */
            /* flex: 1; */
            /* flex-grow: 1; */
            /* flex-shrink: 1; */
            /* width:200px; */
        }

        @media screen and (max-width: 800px){
            .cont .div1 {
                /* flex-basis: 100%; */
            }
        }
    </style>
</head>

<body>
    <div class="cont">
        <div class="div1">test1</div>
        <div class="div2">test2</div>
    </div>
</body>

</html> 


<!-- display: flex; default main axis width = 자기 content만큼 넓이를 가지는 것 > flex-basis나 width로 너비를 주면 너비가 늘어남 -->

<!-- flex basis -->
<!-- 1. flex의 default main axis width는 flex-basis를 이용하면 넓힐 수 있고 이렇게 넓어진 width는 content 넓이까지 줄었다가 다시 basis 넓이까지 다시 늘어났다 할 수 있다.(유동적), 중간에 width나 height가 지정되어 있다면 그 크기까지만 줄었다가 다시 늘어난다. -->
<!-- main axis에 따라 가로길이를 바꿀지 세로길이를 바꿀지 결정하게 된다(width와의 차이점)-->
<!-- content > width > flex-basis 순으로 넓이를 적용하게 된다. -->
<!-- ※ 고정적인 값을 제공하는 width와는 차이가 있다.? 이 의견에 관해선 맞다고는 못할 것 같다 flex-direction: row에서의 flex-container 안에서는 유사하게 동작하기 때문에! -->
<!--    고정적인 값이라고 생각한다면 main-axis에 상관없이 가로길이가 고정이라고 생각하자!(이 개념이 햇갈렸다!) -->
<!-- 여기서 content 넓이까지 줄었다가 다시 basis 넓이까지 늘 수 있는 속성은 flex-grow, flex-shrink 속성 덕분인데.. 아래에서 설명하겠다. -->

<!-- flex-grow -->
<!-- 1. flex-grow는 0이 기본 값(즉 basis적용하기 전 기본 display:flex; width를 가지는 것_content 넓이까지만) -->
<!-- 2. flex-grow의 값으로는 숫자값만이 들어가는데(단위가 안들어감_unitless) 이 숫자 값에 따라 공백을 나눠가진다.
        2.1 flex-basis 적용 전 + flex-grow: "content 넓이를 제외한 공백"을 나눠가진다.  
        2.2 flex-basis 적용 후 + flex-grow: "flex-basis를 제외한 공백"을 나눠가진다.
        2.3 width 적용 후 + flex-grow: "width" 값을 제외한 공백을 나눠가진다.
-->

<!-- flex-shrink -->
<!-- 1. flex-shrink: 1 기본 값, 이 때문에 따로 설정하지않아도 flex-basis로 기본 속성으로 요 동적인 width를 적용할 수 있는 것!-->
<!-- 2. flex-shrink: 0 아이템의 크기가 flex-basis보다 작아지지 않게 만든다. > 이를 이용해 고정 폭을 이용할 수 있다.-->
<!-- 3. flex-shrink: 0 이상 
        3.1 width 적용해도 flex-shrink가 적용된다.
        3.2 flex-basis 적용 flex-shrink가 똑같이 적용된다.
-->

<!-- flex 축약형 -->
<!-- 1.축약형에 들어가기 전에 flex-grow와 flex-shrink 안에는 숫자만 들어가는 것을 기억하자. -->
<!-- 2."flex: 숫자 숫자 단위값" 형태로 쓸 수 있다. -->
<!--    2.1 3중에 1개, 2개 또는 3개 다 써서 flex를 표현할 수 있다. -->
<!--    2.2 1개만 사용할 때 -->
<!--        2.2.1 "flex: 1" or "flex: 1px" -->
<!--        2.2.2 flex: 1: 단위가 없는 값의 첫번째는 flex-grow을 뜻함 -->
<!--        2.2.3 flex: 1px: 단위가 붙었다면 무조건 flex-basis로 뜻함, flex: 1 1px 2;처럼 중간에 쓰지 않는 이상! basis로 인식-->
<!--    2.3 2개만 사용할 때 -->
<!--        2.2.1 "flex: 1 1" or "flex: 1px 1" or "flex: 1 1px" -->
<!--        2.2.2 flex: 1 1: 단위가 없는 값의 첫번째는 flex-grow, 두번째는 flex-shrink을 뜻함 -->
<!--        2.2.3 flex: 1px 1 or flex: 1 1px: 단위가 붙었다면 무조건 flex-basis로 뜻함, 단위가 없는 건 처음 나온 숫자 값이기 때문에 flex-grow를 뜻함, flex: 1 1px 2;처럼 중간에 쓰지 않는 이상! basis로 인식-->
<!--    2.4 3개만 사용할 때 -->
<!--        2.2.1 "flex: 1 1" or "flex: 1px 1" or "flex: 1 1px" -->
<!--        2.2.2 flex: 1 1: 단위가 없는 값의 첫번째는 flex-grow, 두번째는 flex-shrink을 뜻함 -->
<!--        2.2.3 flex: 1px 1 or flex: 1 1px: 단위가 붙었다면 무조건 flex-basis로 뜻함, 단위가 없는 건 처음 나온 숫자 값이기 때문에 flex-grow를 뜻함, flex: 1 1px 2;처럼 중간에 쓰지 않는 이상! basis로 인식-->


<!-- flex-basis 값이 적용되었는데 wrap 속성이 있으면 shrink가 적용이 안되는 건지..
wrap이 있으면 wrap속성 우선 적용 후 shrink 적용 > flex 속성간(flex-basis, flex-wrap, flex-grow, flex-shrink 간에 우선순위가 따로 있는지 여쭤보기 )  -->

